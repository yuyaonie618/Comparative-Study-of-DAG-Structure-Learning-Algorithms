
#run simulation, run different graph structures or edge weights by changing parameters
def run_simulation_grid(
    d_list = [10, 30],
    n_factor_list = [30, 50],
    k_list = [1, 2],
    R = 10,

    model = 'ba', #'ba', 'er'
    weight_regime = 'strong', #'strong', 'weak'
    noise_scale = 1.0,
    sem_type = 'gauss',
    base_seed = 42
):

    results = []

    for d in d_list:
        for n_factor in n_factor_list:
            for k in k_list:
                for r in range(R):

                    #generate true grah
                    seed = base_seed + 100000*d + 1000*n_factor + 10*k + r
                    W_true, A_true, X = generate_simulation_dataset(
                        d=d,
                        n_factor=n_factor,
                        k=k,
                        model=model,
                        weight_regime=weight_regime,
                        noise_scale=noise_scale,
                        sem_type=sem_type,
                        seed=seed
                    )

                    # run NOTEARs
                    start = time.time()
                    A_hat_notears = notears_linear(X, lambda1=0.1, loss_type='l2')
                    elapsed_notears = time.time() - start

                    metrics_notears = evaluate_graph_update(
                        A_true=A_true,
                        A_est=A_hat_notears,
                        runtime=elapsed_notears,
                        count_reversed_as_two=False
                    )
                    metrics_notears.update({
                        'algo': 'NOTEARS',
                        'd': d,
                        'n_factor': n_factor,
                        'n': int(n_factor * d),
                        'k': k,
                        'repeat': r,
                    })
                    results.append(metrics_notears)

                    # run MMHC
                    start = time.time()
                    A_hat_mmhc = run_mmhc_continuous_optimized(X)
                    elapsed_mmhc = time.time() - start

                    metrics_mmhc = evaluate_graph(
                        A_true=A_true,
                        A_est=A_hat_mmhc,
                        runtime=elapsed_mmhc,
                        count_reversed_as_two=False
                    )
                    metrics_mmhc.update({
                        'algo': 'MMHC',
                        'd': d,
                        'n_factor': n_factor,
                        'n': int(n_factor * d),
                        'k': k,
                        'repeat': r,
                    })
                    results.append(metrics_mmhc)

                    # run FGS
                    X_df = pd.DataFrame(X, columns=[f"V{i}" for i in range(X.shape[1])])
                    start = time.time()
                    graph = run_fges_safe(X)
                    elapsed_fgs = time.time() - start
                    node_names = X_df.columns.tolist()
                    A_hat_fgs = tetrad_graph_to_adj_matrix(graph, node_names)
                    metrics_fgs = evaluate_graph(
                        A_true=A_true,
                        A_est=A_hat_fgs,
                        runtime=elapsed_fgs,
                        count_reversed_as_two=False
                    )
                    metrics_fgs.update({
                        'algo': 'FGS',
                        'd': d,
                        'n_factor': n_factor,
                        'n': int(n_factor * d),
                        'k': k,
                        'repeat': r,
                    })
                    results.append(metrics_fgs)
    df_results = pd.DataFrame(results)
    return df_results

#running the simulation example
strong_weight_ba = run_simulation_grid()
strong_weight_ba.to_excel("simulation_strong_ba.xlsx", index=False)
print(strong_weight_result_ba)
